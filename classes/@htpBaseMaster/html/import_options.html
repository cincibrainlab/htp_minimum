
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Import Options XML</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-09-01"><meta name="DC.source" content="import_options.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Import Options XML</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Usage</a></li><li><a href="#2">Parameters</a></li><li><a href="#3">Copyright and Contact Information</a></li><li><a href="#4">import_options</a></li></ul></div><h2 id="1">Usage</h2><p>obj = import_options( obj, xmlfile)</p><h2 id="2">Parameters</h2><div><ul><li>INPUTS: obj, xmlfile</li></ul></div><div><ul><li>OUTPUTS: obj</li></ul></div><p>The input parameter xml_file is an xml file that is in the format seen in the cfg_htpPreprocessingOptions.xml atrribute of an htpPreprocessMaster object.  The second input of obj as the htpPreprocessMaster object is optional depending upon if the function is self-invoked or not.  The output, if the function is not self-invoked, is the htpPreprocessMaster object with the htpcfg attribute updated with options for each stage of the preprocessing experience. output</p><pre>  struct with stage options:
  [1x1] struct
 |--Stage1:  [1x1] struct
 |  |--FilterLow:  [1x4] cell
 |  |--FilterHigh:  [1x5] cell
 |  |--Notch1:  [1x2] cell
 |  |--Resample:  [1x4] cell
 |  '--Rereference:  [1x7] char
 |--Stage2:  [1x1] struct
 |  |--Interpolation:  [1x3] cell
 |  |--CleanMode:  [1x2] cell
 |  '--EpochLength:  [1x3] cell
 '--Stage3:  [1x1] struct
    '--PCA:  [1x3] cell</pre><h2 id="3">Copyright and Contact Information</h2><p>Copyright &copy; 2020 Cincinnati Children's (Pedapati Lab)</p><p>This file is part of High Throughput Pipeline (HTP)</p><p>See https://bitbucket.org/eped1745/htp_stable/src/master/</p><p>Contact: <a href="mailto:ernest.pedapati@cchmc.org">ernest.pedapati@cchmc.org</a></p><h2 id="4">import_options</h2><p>Configuring the options necessary for each stage of preprocessing events for quick future reference and the user is alerted to how many options were imported. Options are pulled from preconfigured xml files that can be modified by user for their preference.</p><pre class="codeinput"><span class="keyword">function</span> obj = import_options( obj, xmlfile)

htpcfg = obj.htpcfg;

optxml = ext_xml2struct( xmlfile );

stageNames = fields(optxml.PreProcessOptions);

<span class="keyword">for</span> i = 1 : length(stageNames)

    stageOpt{i} = fields(optxml.PreProcessOptions.(stageNames{i}));

<span class="keyword">end</span>

o1 = optxml.PreProcessOptions;

<span class="keyword">for</span> j = 1 : length(stageNames)

    s1 = o1.(stageNames{j});

    s1Fields = fields(s1);

    <span class="keyword">for</span> i= 1 : length(s1Fields)
        allopt = [];
        opttemp = s1.(s1Fields{i});
        opttemplength = length(opttemp.opt');

        <span class="keyword">if</span> opttemplength == 1
            allopt = opttemp.opt.Text;
        <span class="keyword">else</span>
            allopt = [opttemp.opt{:}];
            allopt = { allopt.Text};

        <span class="keyword">end</span>
       <span class="comment">% newopt{i,1,j} = s1Fields{i};</span>
       <span class="comment">% newopt{i,2,j} = allopt;</span>

        newStruct.(stageNames{j}).(s1Fields{i}) = allopt;
    <span class="keyword">end</span>

<span class="keyword">end</span>

obj.xml_opt = newStruct;

stagename = fields(obj.xml_opt);

<span class="keyword">for</span> i = 1 : length( stagename )

    stagedetail = fields(obj.xml_opt.(stagename{i}));
    opttemp = obj.xml_opt.(stagename{i});
    <span class="keyword">for</span> j = 1 : length( stagedetail )

        htpcfg.opt.(genvarname([stagename{i} <span class="string">'_'</span> stagedetail{j}])) = opttemp.(stagedetail{j});


    <span class="keyword">end</span>

<span class="keyword">end</span>

obj.htpcfg = htpcfg;

disp(obj.htpcfg.opt);
obj.msgout(sprintf(<span class="string">'Number of Options Imported: %d\n'</span>, length(fields(obj.htpcfg.opt))),<span class="string">'step_complete'</span>);

<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Import Options XML
%%% Usage
%    
% obj = import_options( obj, xmlfile)
% 
%%% Parameters
% 
% * INPUTS: obj, xmlfile
%
% * OUTPUTS: obj
%
% The input parameter xml_file is an xml file that is in the format seen in
% the cfg_htpPreprocessingOptions.xml atrribute of an htpPreprocessMaster
% object.  The second input of obj as the htpPreprocessMaster object is
% optional depending upon if the function is self-invoked or not.  The
% output, if the function is not self-invoked, is the htpPreprocessMaster
% object with the htpcfg attribute updated with options for each stage of 
% the preprocessing experience. 
% output
% 
%    struct with stage options:
%    [1x1] struct
%   |REPLACE_WITH_DASH_DASHStage1:  [1x1] struct
%   |  |REPLACE_WITH_DASH_DASHFilterLow:  [1x4] cell
%   |  |REPLACE_WITH_DASH_DASHFilterHigh:  [1x5] cell
%   |  |REPLACE_WITH_DASH_DASHNotch1:  [1x2] cell
%   |  |REPLACE_WITH_DASH_DASHResample:  [1x4] cell
%   |  'REPLACE_WITH_DASH_DASHRereference:  [1x7] char
%   |REPLACE_WITH_DASH_DASHStage2:  [1x1] struct
%   |  |REPLACE_WITH_DASH_DASHInterpolation:  [1x3] cell
%   |  |REPLACE_WITH_DASH_DASHCleanMode:  [1x2] cell
%   |  'REPLACE_WITH_DASH_DASHEpochLength:  [1x3] cell
%   'REPLACE_WITH_DASH_DASHStage3:  [1x1] struct
%      'REPLACE_WITH_DASH_DASHPCA:  [1x3] cell
%
%%% Copyright and Contact Information
% Copyright Â© 2020 Cincinnati Children's (Pedapati Lab)
%
% This file is part of High Throughput Pipeline (HTP)
% 
% See https://bitbucket.org/eped1745/htp_stable/src/master/
% 
% Contact: ernest.pedapati@cchmc.org

%% import_options
% Configuring the options necessary for each stage
% of preprocessing events for quick future reference and the user is 
% alerted to how many options were imported.
% Options are pulled from preconfigured xml files
% that can be modified by user for their preference.

function obj = import_options( obj, xmlfile)

htpcfg = obj.htpcfg;

optxml = ext_xml2struct( xmlfile );

stageNames = fields(optxml.PreProcessOptions);

for i = 1 : length(stageNames)
    
    stageOpt{i} = fields(optxml.PreProcessOptions.(stageNames{i}));
    
end

o1 = optxml.PreProcessOptions;

for j = 1 : length(stageNames)
    
    s1 = o1.(stageNames{j});
    
    s1Fields = fields(s1);
    
    for i= 1 : length(s1Fields)
        allopt = [];
        opttemp = s1.(s1Fields{i});
        opttemplength = length(opttemp.opt');
        
        if opttemplength == 1
            allopt = opttemp.opt.Text;
        else
            allopt = [opttemp.opt{:}];
            allopt = { allopt.Text};
            
        end
       % newopt{i,1,j} = s1Fields{i};
       % newopt{i,2,j} = allopt;
        
        newStruct.(stageNames{j}).(s1Fields{i}) = allopt;
    end
    
end

obj.xml_opt = newStruct;

stagename = fields(obj.xml_opt);

for i = 1 : length( stagename )
   
    stagedetail = fields(obj.xml_opt.(stagename{i}));
    opttemp = obj.xml_opt.(stagename{i});
    for j = 1 : length( stagedetail )
        
        htpcfg.opt.(genvarname([stagename{i} '_' stagedetail{j}])) = opttemp.(stagedetail{j});
        
        
    end
    
end

obj.htpcfg = htpcfg;

disp(obj.htpcfg.opt);
obj.msgout(sprintf('Number of Options Imported: %d\n', length(fields(obj.htpcfg.opt))),'step_complete');

end

##### SOURCE END #####
--></body></html>